<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>KEMTLS</title><link>https://kemtls.org/tag/kemtls/</link><atom:link href="https://kemtls.org/tag/kemtls/index.xml" rel="self" type="application/rss+xml"/><description>KEMTLS</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Tue, 06 Dec 2022 12:01:41 +0100</lastBuildDate><image><url>https://kemtls.org/media/icon_hu97de4da46f16ac919c0743995c37a167_12957_512x512_fill_lanczos_center_3.png</url><title>KEMTLS</title><link>https://kemtls.org/tag/kemtls/</link></image><item><title>KEMTLS vs. Post-Quantum TLS: Performance on Embedded Systems</title><link>https://kemtls.org/publication/kemtls-embedded/</link><pubDate>Tue, 06 Dec 2022 12:01:41 +0100</pubDate><guid>https://kemtls.org/publication/kemtls-embedded/</guid><description/></item><item><title>A tale of two models: formal analysis of KEMTLS in Tamarin</title><link>https://kemtls.org/event/2022-09-27-esorics-kemtls-tamarin/</link><pubDate>Tue, 27 Sep 2022 15:00:00 +0200</pubDate><guid>https://kemtls.org/event/2022-09-27-esorics-kemtls-tamarin/</guid><description/></item><item><title>A tale of two models: formal verification of KEMTLS in Tamarin</title><link>https://kemtls.org/publication/kemtls-tamarin/</link><pubDate>Tue, 27 Sep 2022 15:00:00 +0200</pubDate><guid>https://kemtls.org/publication/kemtls-tamarin/</guid><description>&lt;h2 id="artefacts">Artefacts&lt;/h2>
&lt;ul>
&lt;li>The Tamarin model based on the Cremers et al. model:
&lt;ul>
&lt;li>&lt;a href="https://github.com/kemtls/KEMTLS-TLS13Tamarin" target="_blank" rel="noopener">Model and proofs&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>The Tamarin model that closely resembles our pen-and-paper proofs:
&lt;ul>
&lt;li>&lt;a href="https://github.com/kemtls/Tamarin-multi-stage-model" target="_blank" rel="noopener">Model and proofs&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>A tale of two models: Formal analysis of KEMTLS in Tamarin</title><link>https://kemtls.org/slides/kemtls-tamarin/</link><pubDate>Mon, 19 Sep 2022 10:51:35 +0200</pubDate><guid>https://kemtls.org/slides/kemtls-tamarin/</guid><description>
&lt;section>
&lt;h2>&lt;span style="font-family: cursive;">A tale of two models:&lt;/span>&lt;/h2>
&lt;h3>Formal analysis of KEMTLS in Tamarin&lt;/h3>
Sofía Celi, Jonathan Hoyland, Douglas Stebila and &lt;strong>Thom Wiggers&lt;/strong>.
&lt;/section>
&lt;section>
&lt;section>
&lt;p class="r-fit-text">Once upon a time...&lt;/p>
&lt;/section>
&lt;section>
&lt;ul>
&lt;li class="fragment">Observation: PQ signatures are quite big and/or slow&lt;/li>
&lt;li class="fragment">Idea: Use KEMs for authentication&lt;/li>
&lt;li class="fragment">Proposal: &lt;a href="https://kemtls.org">&lt;strong>KEMTLS&lt;/strong>&lt;/a>&lt;/li>
&lt;/ul>
&lt;/section>
&lt;/section>
&lt;section>
&lt;section>
&lt;h2>KEMTLS&lt;/h2>
&lt;div class="t-container">
&lt;div class="r-stack col">
&lt;div class="mermaid">
sequenceDiagram
Client->>+Server: ClientHello: ephemeral kex
Server->>-Client: ServerHello: ephemeral kex
Server->>+Client: Certificate: static KEM pk
Client->>-Server: Ciphertext
Client->>Server: ClientFinished
rect rgba(0, 0, 0, 0)
Client-->>Server: Application Data
end
Server->>Client: ServerFinished
Server-->>Client: Application Data
&lt;/div>
&lt;div class="fragment mermaid" style="background: #fff">
sequenceDiagram
Client->>+Server: ClientHello: ephemeral kex
Server->>-Client: ServerHello: ephemeral kex
Server->>+Client: Certificate: static KEM pk
Client->>-Server: Ciphertext
Client->>Server: ClientFinished
rect pink
Client-->>Server: Application Data
end
Server->>Client: ServerFinished
Server-->>Client: Application Data
&lt;/div>
&lt;/div>
&lt;div class="col" >
&lt;ul>
&lt;li>Ephemeral KEM key exchange&lt;/li>
&lt;li>KEM public key in certificate&lt;/li>
&lt;li>Avoid extra round-trip by letting client send data immediately&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/section>
&lt;section>
&lt;h2>KEMTLS variants&lt;/h2>
&lt;ul>
&lt;li class="fragment">Mutual authentication&lt;/li>
&lt;li class="fragment">What if the client already knows the server's public key?
&lt;ul>
&lt;li>E.g. resumption, or PSK-like hardcoded keys&lt;/li>
&lt;li>KEMTLS-PDK: KEMTLS with Pre-Distributed Keys&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/section>
&lt;section>
&lt;h2>Pen-and-paper proofs&lt;/h2>
&lt;ul style="display: block; width: 100%">
&lt;li>Original KEMTLS paper
&lt;ul>
&lt;li>Server-to-client authentication&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>KEMTLS-PDK paper:
&lt;ul>
&lt;li>Server-to-client authentication&lt;/li>
&lt;li>Mutual authentication&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p class="fragment">Both proofs have seen several corrections, and live in similar, but slightly separate models.&lt;/p>
&lt;/section>
&lt;/section>
&lt;section>
&lt;h2>Computer-aided proofs&lt;/h2>
&lt;ul>
&lt;li> Proving things by hand:
&lt;ul>
&lt;li>Tedious, error-prone work&lt;/li>
&lt;li>Very easy to subconciously fill in gaps in the analysis in your mind&lt;/li>
&lt;li>Very hard to consider many variant protocols together&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li class="fragment">Computers:
&lt;ul>
&lt;li>Very, very good at being very, very literal&lt;/li>
&lt;li>Will not accept handwavyness&lt;/li>
&lt;li>Have no problem keeping track of different protocol variants&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/section>
&lt;section>
&lt;h2>Protocol analysis of TLS 1.3&lt;/h2>
&lt;ul>
&lt;li>TLS 1.3 has seen lots of pen-and-paper and computer-aided analysis work&lt;/li>
&lt;li>Including analyses in Tamarin (Cremers et al.), Proverif (Barghavan et al.)&lt;/li>
&lt;li>TLS 1.3 was developed using a "design-break-fix-release" cycle rather than "design-release-break-patch" cycle (Paterson and Van der Merwe)&lt;/li>
&lt;/ul>
&lt;/section>
&lt;section data-visibility="hidden">
&lt;section>
&lt;h2>Tamarin&lt;/h2>
&lt;p>
Tamarin models protocols as &lt;em>rules&lt;/em> that take in a set of &lt;em>variables&lt;/em> and one or more &lt;em>messages&lt;/em>, and then emit new variables and messages.
&lt;/p>
&lt;p class="fragment">The (Dolev-Yao) attacker controls the network and can read, send, change, drop all messages.
&lt;/p>
&lt;p class="fragment">
Any cryptographic operation is &lt;em>perfect&lt;/em>.
Cryptographic compromise is modeled through manually modeled "oracles" that reveal specific keys.
&lt;/p>
&lt;/section>
&lt;section>
&lt;h2>Tamarin rules&lt;/h2>
&lt;pre>&lt;code class="language-plaintext" data-trim data-line-numbers="1-11|2-4|5-7|8-11">
rule ProtocolMessageI:
[
In(message), VariableI(x)
]
--[
ReceivedMessageFact(message, x)
]->
[
Out(SomeOtherMessage),
VariableII(operation(x))
]
&lt;/code>&lt;/pre>
&lt;/section>
&lt;section>
&lt;h2>Tamarin Lemmas&lt;/h2>
&lt;pre>&lt;code class="language-plaintext" data-trim data-line-numbers="1-13|2|3-5|6|7-8|9-12">
lemma my_lemma:
"All key #i #j.
ExchangedKey(key)@#i // some protocol-emitted fact
// over `key` at time #i
&amp; K(key)@#j // Adversary knows `key` at #j
==> /* then */
/* exists a time #z */
Ex #z.
/* at which key was revealed */
RevealedKey(key)@#z
/* and #z was before #j */
&amp; #z &lt; #j
"
&lt;/code>&lt;/pre>
&lt;/section>
&lt;/section>
&lt;section>
&lt;section>
&lt;h2>Two approaches&lt;/h2>
&lt;div class="t-container">
&lt;div class="col">
&lt;h3>Approach #1&lt;/h3>
Take an existing model and adapt it to represent KEMTLS
&lt;/div>
&lt;div class="col">
&lt;h3>Approach #2&lt;/h3>
Build a new model from scratch
&lt;/div>
&lt;/div>
&lt;/section>
&lt;section>
&lt;h2>Game plan&lt;/h2>
&lt;div class="t-container">
&lt;div class="col">
&lt;h3>Approach #1&lt;/h3>
&lt;ol>
&lt;li>Take the &lt;a href="https://tls13tamarin.github.io">TLS 1.3 Tamarin model by Cremers et al.&lt;/a>&lt;/li>
&lt;li>Change it to represent KEMTLS(-PDK)&lt;/li>
&lt;li>???&lt;/li>
&lt;li>Prove it!&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="col">
&lt;h3>Approach #2&lt;/h3>
&lt;ol>
&lt;li>Simplify the protocol to its cryptographic core&lt;/li>
&lt;li>Convert the pen-and-paper claimed security properties to Tamarin&lt;/li>
&lt;li>???&lt;/li>
&lt;li>Prove it&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/section>
&lt;section style="font-size: 80%">
&lt;h2>Motivations&lt;/h2>
&lt;div class="t-container">
&lt;div class="col">
&lt;h3>Approach #1&lt;/h3>
&lt;ol>
&lt;li>Tried-and-tested TLS model&lt;/li>
&lt;li>Many tedious protocol details already modeled:
&lt;ul>
&lt;li>Key derivation&lt;/li>
&lt;li>Handshake encryption&lt;/li>
&lt;li>Message syntax&lt;/li>
&lt;li>Record layer&lt;/li>
&lt;li>Certificate PKI&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Many existing lemmas: both security lemmas as well as "helper" lemmas&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="col">
&lt;h3>Approach #2&lt;/h3>
&lt;ul>
&lt;li>Precisely model the different levels of forward-secrecy and explicit authentication properties claimed in our pen-and-paper proofs&lt;/li>
&lt;li>Don't carry around the baggage of handshake encryption, full TLS key schedule&lt;/li>
&lt;li>Analyze KEMTLS' deniability features&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/section>
&lt;section style="font-size: 60%">
&lt;h2>Feature comparison&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Feature&lt;/th>
&lt;th>Model #1&lt;/th>
&lt;th>Model #2&lt;/th>
&lt;/tr>
&lt;tr>
&lt;th colspan="3">&lt;em>Protocol modelling&lt;/em>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Encrypted handshake messages&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>❌&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HKDF and HMAC decomposed into hash&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>❌&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Key exchange and auth KEMs are same algorithm&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>❌&lt;/td>
&lt;/tr>
&lt;tr>
&lt;th colspan="3">&lt;em>Security properties&lt;/em>&lt;/th>
&lt;/tr>
&lt;tr>
&lt;td>Adversary can reveal long-term keys&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Adversary can reveal ephemeral keys&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>❌&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Adversary can reveal intermediate session keys&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Secrecy of handshake and traffic keys&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Forward Secrecy&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Multiple flavours of forward secrecy&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Explicit authentication&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Deniability&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/section>
&lt;section style="font-size: 80%">
&lt;h2>Results&lt;/h2>
&lt;div class="t-container">
&lt;div class="col">
&lt;h3>Approach #1&lt;/h3>
&lt;ul>
&lt;li>Managed to make the model auto-prove
&lt;ul>&lt;li style="color: grey; font-size: 50%">We did disable some features not immediately relevant to KEMTLS (including post-handshake authentication, PSK)&lt;/li>&lt;/ul>
&lt;/li>
&lt;li>Run-time: 28 hours (many, many cores)&lt;/li>
&lt;li>Memory required: >120GB of RAM&lt;/li>
&lt;li>Found a minor bug in a lemma of the Cremers et al. model&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="col">
&lt;h3>Approach #2&lt;/h3>
&lt;ul>
&lt;li>Found several minor mistakes in stated forward secrecy and authentication properties of KEMTLS and KEMTLS-PDK&lt;/li>
&lt;li>Proves most security properties of KEMTLS in &lt;strong>minutes&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/section>
&lt;section>
&lt;h2>Some more thoughts on Model #2&lt;/h2>
&lt;ul>
&lt;li>Surprisingly straightforward model:
&lt;ul>
&lt;li>Direct translation of security properties to Tamarin&lt;/li>
&lt;li>~40 hours of work: much less than for #1&lt;/li>
&lt;li>Modeling in both instances done by "newbies"&lt;/li>
&lt;li>0 helper lemmas (no &lt;code>[reuse]&lt;/code>!)&lt;/li>
&lt;li>Everything auto-proves&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Maybe Tamarin is not so scary after all?&lt;/li>
&lt;/ul>
&lt;/section>
&lt;/section>
&lt;section>
&lt;section>&lt;h1>Wrap-up&lt;/h1>&lt;/section>
&lt;section>
&lt;h3>A tale of two models: formal analysis of KEMTLS in Tamarin&lt;/h3>
&lt;ul>
&lt;li>Two approaches, two viewpoints: more confidence&lt;/li>
&lt;li>It is possible to rigorize your pen-and-paper proofs in Tamarin&lt;/li>
&lt;li>Full version of the paper and model source code available at &lt;a href="https://kemtls.org">https://kemtls.org/&lt;/a>.&lt;/li>
&lt;/ul>
&lt;p class="fragment">Model your own protocols!&lt;/p>
&lt;p class="fragment">Thanks for your attention&lt;/p>
&lt;p style="font-family: monospace; font-size: 80%">🐦 &lt;a href="https://twitter.com/thomwiggers">@thomwiggers&lt;/a>&lt;/p>
&lt;/section>
&lt;/section></description></item><item><title>KEMTLS with Delayed Forward Identity Protection in (Almost) a Single Round</title><link>https://kemtls.org/publication/kemtls-epoch/</link><pubDate>Sat, 18 Jun 2022 16:20:10 +0200</pubDate><guid>https://kemtls.org/publication/kemtls-epoch/</guid><description/></item><item><title>Implementing and Measuring KEMTLS</title><link>https://kemtls.org/publication/measuring-kemtls/</link><pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate><guid>https://kemtls.org/publication/measuring-kemtls/</guid><description/></item><item><title>More efficient post-quantum KEMTLS with pre-distributed public keys</title><link>https://kemtls.org/publication/kemtlspdk/</link><pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate><guid>https://kemtls.org/publication/kemtlspdk/</guid><description>&lt;h2 id="proof">Proof&lt;/h2>
&lt;p>The full version is linked above.&lt;/p>
&lt;h2 id="software">Software&lt;/h2>
&lt;p>The implementation can be found &lt;a href="https://github.com/thomwiggers/kemtls-experiment/tree/reimplementation" target="_blank" rel="noopener">on Github&lt;/a>.&lt;/p></description></item><item><title>KEMTLS: securing TLS connections from quantum adversaries</title><link>https://kemtls.org/event/2021-03-29-cloudflaretv/</link><pubDate>Mon, 29 Mar 2021 14:00:00 +0200</pubDate><guid>https://kemtls.org/event/2021-03-29-cloudflaretv/</guid><description/></item><item><title>Post-Quantum TLS without handshake signatures at RWC 2021</title><link>https://kemtls.org/event/2021-01-11-rwc/</link><pubDate>Mon, 11 Jan 2021 18:15:00 +0100</pubDate><guid>https://kemtls.org/event/2021-01-11-rwc/</guid><description>&lt;h1 id="post-quantum-tls-with-kems-instead-of-signatures">Post-Quantum TLS with KEMs instead of signatures&lt;/h1>
&lt;p>&lt;em>This article has also been posted to &lt;a href="https://claucece.github.io/2021/01/10/cf-kemtls.html" target="_blank" rel="noopener">Sofía Celi&amp;rsquo;s blog&lt;/a> and the &lt;a href="https://blog.cloudflare.com/kemtls-post-quantum-tls-without-signatures/" target="_blank" rel="noopener">Cloudflare blog&lt;/a>.&lt;/em>&lt;/p>
&lt;p>Fundamentally, the Transport Layer Security protocol (TLS), which
secures most of the Internet connections, has mainly been a key exchange
authenticated by digital signatures.&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> Even though it has undergone
major changes since 1994, when SSL 1.0 was introduced by Netscape, it&amp;rsquo;s
main mechanism has remained the same. The key exchange that is used was
first based on RSA and later on (elliptic curve) Diffie-Hellman. The
signatures used for authentication have almost always been RSA-based,
though in recent years other kinds of signatures have been adopted,
mainly ECDSA and Ed25519. This recent change to elliptic curve
cryptography at both at a key exchange and signature level has resulted
in considerable speed and bandwidth benefits in comparison to classic
Diffie-Hellman and RSA.&lt;/p>
&lt;p>TLS is the main protocol that protects the connections we use everyday.
It is everywhere: it is used when we buy products online, when we
register for a newsletter or when we access any kind of website. But,
with the imminent threat of the arrival of
&lt;a href="https://blog.cloudflare.com/securing-the-post-quantum-world/" target="_blank" rel="noopener">quantum computers&lt;/a>
(a threat that seems to be getting closer and closer), we need to
reconsider again the future of TLS. &lt;a href="https://blog.cloudflare.com/the-tls-post-quantum-experiment/" target="_blank" rel="noopener">A wide-scale post-quantum
experiment&lt;/a>
was carried out by Cloudflare and Google: two post-quantum key exchanges
were integrated into their TLS stack and deployed at their edge servers
and in Chrome Canary clients. The goal of that experiment was to
evaluate the performance and feasibility of deployment of two
post-quantum key exchanges in TLS.&lt;/p>
&lt;p>Similar experiments have been proposed for introducing post-quantum
algorithms into the TLS handshake itself. But, they all seem infeasible
to be introduced at authentication by signature and key exchange levels
as, unfortunately, post-quantum cryptographic primitives are bigger, or
slower (or both) than their predecessors. The proposed algorithms under
consideration in the &lt;a href="https://csrc.nist.gov/Projects/post-quantum-cryptography/round-3-submissions" target="_blank" rel="noopener">NIST post-quantum standardization
process&lt;/a>
use larger mathematical objects than what is used for elliptic curves,
traditional Diffie-Hellman or RSA. As a result, the size of public keys,
signatures and key exchange material is much bigger than those from
elliptic curves, Diffie-Hellman or RSA.&lt;/p>
&lt;p>How can we solve this problem? How can we use post-quantum algorithms as
part of the TLS handshake without making the material too big to be
transmitted? In this blogpost, we will introduce a new mechanism for
making this happen, explain how it can be integrated into the handshake
and talk about implementation details. The key observation in this
mechanism is that, while post-quantum algorithms have bigger
communication size than their predecessors, post-quantum &lt;em>key exchanges&lt;/em>
have somewhat smaller sizes than post-quantum &lt;em>signatures&lt;/em>, so we can
try to replace key exchanges with signatures in some places to save
space. We will only focus on the TLS 1.3 handshake as it is the TLS
version that should be currently used.&lt;/p>
&lt;h2 id="the-past-experiments-making-the-traditional-tls-13-handshake-post-quantum">The past experiments: making the traditional TLS 1.3 handshake post-quantum&lt;/h2>
&lt;p>&lt;a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">TLS 1.3&lt;/a> was introduced in
August 2018 with many security and performance improvements (notably,
having only one round-trip to complete the handshake). But TLS 1.3 is
designed for a world with classical computers, and some of its
functionalities will be broken by quantum computers when they arrive.&lt;/p>
&lt;p>The primary goals of TLS 1.3 are to provide authentication (the server
side of the channel is always authenticated, the client side is
optionally authenticated), confidentiality and integrity by using a
handshake protocol and a record protocol. The handshake protocol, the
one of interest for us today, establishes the cryptographic parameters
for securing and authenticating a connection. It can be thought of as of
having three main phases, as defined in
&lt;a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">RFC8446&lt;/a>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The Parameter Negotiation phase (referred to as &amp;lsquo;Server Parameters&amp;rsquo;
in RFC8446), which establishes other handshake parameters (whether the
client is authenticated, application-layer protocol support, etc).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Key Exchange phase, which establishes shared keying material and
selects the cryptographic parameters to be used. Everything after this
phase will be encrypted.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Authentication phase, which authenticates the server (and,
optionally, the client) and provides key confirmation and handshake
integrity.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The main idea of past experiments that introduced post-quantum
algorithms into the handshake of TLS 1.3 was to use them in place of
classical algorithms by advertising them as part of the &lt;a href="https://tools.ietf.org/html/rfc8446#section-4.2.7" target="_blank" rel="noopener">supported
groups&lt;/a> (an
extension used by the client to indicate which named groups -Elliptic
Curve Groups, Finite Field Groups- it supports for key exchange) and
&lt;a href="https://tools.ietf.org/html/rfc8446#section-4.2.8" target="_blank" rel="noopener">key share&lt;/a> (an
extension which contains the endpoint&amp;rsquo;s cryptographic parameters)
extensions, and, therefore, establishing with them the negotiated
connection parameters. Key encapsulation mechanisms (KEMs) are an
abstraction of the basic key exchange primitive and were used to
generate the shared secrets. In the case of using a &lt;a href="https://tools.ietf.org/html/rfc8446#section-4.2.11" target="_blank" rel="noopener">pre-shared
key&lt;/a>, its symmetric
algorithms can be easily replaced by post-quantum KEMs, as well; and, in
the case of password-authenticated TLS, there has been some
&lt;a href="https://eprint.iacr.org/2017/1192.pdf" target="_blank" rel="noopener">proposed ideas&lt;/a> on how to use
post-quantum algorithms with them.&lt;/p>
&lt;p>Most of the above ideas only provide what is often defined as
&amp;rsquo;transitional security&amp;rsquo;, as its main focus is providing
quantum-resistant confidentiality, but do not take into account
quantum-resistant authentication. The idea of using post-quantum
signatures for TLS authentication is possible, but the sizes of
post-quantum signatures are larger than traditional ones. Furthermore,
it is &lt;a href="https://csrc.nist.gov/Presentations/2019/the-2nd-round-of-the-nist-pqc-standardization-proc" target="_blank" rel="noopener">worth noting&lt;/a>
that using post-quantum signatures is much heavier than using
post-quantum KEMs.&lt;/p>
&lt;p>We can estimate the impact of such a replacement on network traffic by
simply looking at the sum of the cryptographic objects that are
transmitted during the handshake. In a typical TLS 1.3 handshake using
elliptic curve X25519 and RSA-2048, such a handshake would transmit 1376
bytes corresponding to: the public keys for key exchange, the
certificate, the signature of the handshake, and the certificate chain.
If we were to replace X25519 by the post-quantum KEM
&lt;a href="https://pq-crystals.org/kyber/" target="_blank" rel="noopener">Kyber512&lt;/a> and RSA by the post-quantum
signature &lt;a href="https://pq-crystals.org/dilithium/" target="_blank" rel="noopener">Dilithium II&lt;/a>, two of
the more efficient proposals, the size transmitted data would increase
to 10036 bytes.&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> The increase is mostly due to the size of the
post-quantum signature algorithm.&lt;/p>
&lt;p>The question then is: how can we achieve full post-quantum security and
give a handshake that is efficient to be used?&lt;/p>
&lt;h2 id="a-more-efficient-proposal-kemtls">A more efficient proposal: KEMTLS&lt;/h2>
&lt;p>There is a long history of other mechanisms, besides signatures, being
used for authentication. Modern protocols, such as the Signal protocol,
the Noise framework or WireGuard, rely on key exchange mechanisms for
authentication; but are somewhat unsuitable for the TLS 1.3 case as they
expect the long-term key material to be known in advance by the
interested parties.&lt;/p>
&lt;p>The &lt;a href="https://eprint.iacr.org/2015/978.pdf" target="_blank" rel="noopener">OPTLS proposal&lt;/a> by Krawczyk
and Wee gives authentication for the TLS handshake without signatures by
using a non-interactive key exchange (NIKE). However, the only somewhat
efficient construction for a post-quantum NIKE is CSIDH, the security of
which is the subject of ongoing debate. But, we can build on this idea
by using KEMs for authentication. KEMTLS, the current proposed
experiment, replaces the handshake signature by a post-quantum KEM key
exchange. It was designed and introduced by Peter Schwabe, Douglas
Stebila and Thom Wiggers on the
&lt;a href="https://thomwiggers.nl/publication/kemtls/kemtls.pdf" target="_blank" rel="noopener">publication &amp;lsquo;Post-Quantum TLS Without Handshake Signatures&amp;rsquo;&lt;/a>.&lt;/p>
&lt;p>KEMTLS, therefore, gives the same goals as TLS 1.3 (authentication,
confidentiality and integrity) in the face of quantum computers for both
clients and servers. One small difference compared to TLS 1.3 is that
KEMTLS only allows to send application data since the second
client-to-server TLS message flow (TLS 1.3 allows the server to send
encrypted and authentication application data in its first response
message).&lt;/p>
&lt;p>Intuitively, the handshake signature in TLS 1.3 proves possession of the
private key corresponding to the public key certified in the TLS 1.3
server certificate. For these signature schemes, this is the
straightforward way to prove possession; but it&amp;rsquo;s also possible to make
such proof through key exchanges. By carefully considering the key
derivation sequence, only the server holding the private key that
corresponds to the certified public key can decrypt any messages sent by
the client to the server. Therefore, implicit authentication is
fulfilled. It is worth noting that KEMTLS still relies on signatures by
certificate authorities to authenticate the long-term KEM keys.&lt;/p>
&lt;p>As said, KEMTLS&amp;rsquo; application data transmitted during the handshake is
implicitly, rather than explicitly authenticated (as in TLS 1.3), and
has slightly weaker downgrade resilience and forward secrecy; but full
downgrade resilience and forward secrecy is achieved once the KEMTLS
handshake completes.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="TLS vs KEMTLS state diagram" srcset="
/event/2021-01-11-rwc/statediagrams_hu064719642517c0de8b7e0d5c695ad3f3_244144_9b97a23c926d29c01ca53dc63b2f72b0.webp 400w,
/event/2021-01-11-rwc/statediagrams_hu064719642517c0de8b7e0d5c695ad3f3_244144_5c1216ea991f74ffe98a721a769593e8.webp 760w,
/event/2021-01-11-rwc/statediagrams_hu064719642517c0de8b7e0d5c695ad3f3_244144_1200x1200_fit_q75_h2_lanczos.webp 1200w"
src="https://kemtls.org/event/2021-01-11-rwc/statediagrams_hu064719642517c0de8b7e0d5c695ad3f3_244144_9b97a23c926d29c01ca53dc63b2f72b0.webp"
width="760"
height="460"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>By replacing the handshake signature by a KEM key exchange, we reduce
the size of the data transmitted in the example handshake using Kyber512
and Dilithium II to 8344 bytes, a significant reduction. Even for
algorithms, such the NTRU-assumption based KEM NTRU and signature
algorithm Falcon, that have a less-pronounced size gap, we still reduce
bytes. KEM operations are typically computationally much lighter than
signing operations as well, which makes the reduction even more
significant.&lt;/p>
&lt;p>KEMTLS was presented at ACM CCS 2020. You can read more about its
details in &lt;a href="https://thomwiggers.nl/publication/kemtls/kemtls.pdf" target="_blank" rel="noopener">the paper&lt;/a>. It was
initially &lt;a href="https://github.com/thomwiggers/kemtls-experiment" target="_blank" rel="noopener">implemented in the RustTLS library&lt;/a>
by Thom Wiggers using optimized C and assembly implementations of the post-quantum
algorithms provided by the &lt;a href="https://github.com/PQClean/PQClean" target="_blank" rel="noopener">PQClean&lt;/a> and
&lt;a href="https://openquantumsafe.org/" target="_blank" rel="noopener">Open Quantum Safe&lt;/a> projects.&lt;/p>
&lt;h2 id="cloudflare-and-kemtls-the-implementation">Cloudflare and KEMTLS: the implementation&lt;/h2>
&lt;p>As part of our effort to show that TLS can be completely post-quantum
safe, we implemented the full KEM TLS handshake over the Golang&amp;rsquo;s TLS
1.3 suite. The implementation was done in several steps:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>We first needed to clone our own version of Golang, so we could add
different post-quantum algorithms to it. You can find our own version
&lt;a href="https://github.com/cloudflare/go/" target="_blank" rel="noopener">here&lt;/a>. This code gets constantly updated
with every release of Golang, following
&lt;a href="https://github.com/cloudflare/go/wiki/Starting-out" target="_blank" rel="noopener">these steps&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We needed to implement post-quantum algorithms in Golang, which we
did on our own cryptographic library
&lt;a href="https://github.com/cloudflare/circl/tree/master/kem" target="_blank" rel="noopener">CIRCL&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>As we cannot force certificate authorities to use certificates with
long-term key post-quantum KEM keys, we decided to use &lt;a href="https://blog.cloudflare.com/keyless-delegation/" target="_blank" rel="noopener">Delegated
Credentials&lt;/a>. A
delegated credential is a short-lasting key that the certificate&amp;rsquo;s
owner has delegated for use in TLS. Therefore, they can be used for
having post-quantum KEM keys. See its implementation in our Golang
code
&lt;a href="https://github.com/cloudflare/go/tree/cf-delegated-credentials" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We implemented mutual auth KEMTLS by using Delegated Credentials for
the authentication process. See its implementation in our Golang
code &lt;a href="https://github.com/cloudflare/go/tree/cf-pq-kemtls" target="_blank" rel="noopener">here&lt;/a>.
You can also check its
&lt;a href="https://github.com/cloudflare/go/blob/cf-pq-kemtls/src/crypto/tls/delegated_credentials_test.go#L774" target="_blank" rel="noopener">test&lt;/a>
for an overview of how it works.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Implementing KEMTLS was a straightforward process, although it did require
changes to the way Golang handles a TLS 1.3 handshake and how the key schedule
works.&lt;/p>
&lt;p>A &amp;ldquo;regular&amp;rdquo; TLS 1.3 handshake in Golang (from the server perspective) looks like
this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">hs&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">serverHandshakeStateTLS13&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">handshake&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">c&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">hs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">c&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// For an overview of the TLS 1.3 handshake, see RFC 8446, Section 2.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">hs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">processClientHello&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">hs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">checkForResumption&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">hs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">pickCertificate&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">buffering&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">hs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">sendServerParameters&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">hs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">sendServerCertificate&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">hs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">sendServerFinished&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Note that at this point we could start sending application data without
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// waiting for the client&amp;#39;s second flight, but the application might not
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// expect the lack of replay protection of the ClientHello parameters.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">flush&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">hs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">readClientCertificate&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">hs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">readClientFinished&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">StoreUint32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">handshakeStatus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We had to interrupt at the point that the server sends the Certificate
(&lt;code>sendServerCertificate()&lt;/code>) in order to send the KEMTLS specific messages. In
the same way, we had to add the appropriate KEM TLS messages to the client&amp;rsquo;s
handshake. And, as we didn&amp;rsquo;t want to change so much the way Golang handles TLS
1.3, we only added one new constant to the configuration that can be used by
a server in order to ask for the Client&amp;rsquo;s Certificate (the constant is
&lt;code>serverConfig.ClientAuth = RequestClientKEMCert&lt;/code>).&lt;/p>
&lt;p>The implementation is easy to work with: if a delegated credential or
a certificate has a public key of a supported post-quantum KEM algorithm, the
handshake will proceed with KEMTLS. If the server requests for a Client KEMTLS
Certificate, the handshake will invoke client KEMTLS authentication.&lt;/p>
&lt;p>Many thanks to everyone involved in the project: Chris Wood, Armando
Faz-Hernandez, Thom Wiggers, Bas Westerbaan, Peter Wu, Peter Schwabe, Goutam
Tamvada, Douglas Stebila, Thibault Meunier, and the whole Cloudflare
cryptography team.&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>It is worth noting that the RSA key transport in TLS ≤1.2 authenticates
the server by RSA public key encryption, although the server&amp;rsquo;s RSA public key
is certified using RSA signatures by Certificate Authorities.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>These numbers, as we do in the paper, are based on the round-2 submissions.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Post-Quantum TLS without handshake signatures</title><link>https://kemtls.org/event/2020-11-12-acmccs_kemtls/</link><pubDate>Mon, 09 Nov 2020 00:00:00 +0000</pubDate><guid>https://kemtls.org/event/2020-11-12-acmccs_kemtls/</guid><description/></item><item><title>Post-Quantum TLS without handshake signatures</title><link>https://kemtls.org/event/2020-10-05-lorentz_workshop_kemtls/</link><pubDate>Mon, 05 Oct 2020 00:00:00 +0000</pubDate><guid>https://kemtls.org/event/2020-10-05-lorentz_workshop_kemtls/</guid><description/></item><item><title>Post-Quantum TLS without handshake signatures</title><link>https://kemtls.org/publication/kemtls/</link><pubDate>Tue, 05 May 2020 00:00:00 +0000</pubDate><guid>https://kemtls.org/publication/kemtls/</guid><description>&lt;h2 id="software">Software&lt;/h2>
&lt;p>The raw data and software that accompanies this publication can be found at &lt;a href="https://github.com/thomwiggers/kemtls-experiment/" target="_blank" rel="noopener">Github&lt;/a>.&lt;/p></description></item></channel></rss>